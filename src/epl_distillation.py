# -*- coding: utf-8 -*-
"""EPL_distillation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v-Y5hoiaDaXiU5kkdFl5X9AeDrm9QScn
"""

import numpy as np
from qiskit import QuantumCircuit
from qiskit.quantum_info import DensityMatrix, Operator, partial_trace
from typing import Tuple


def EPL_distillation_protocol(rho: DensityMatrix) -> Tuple[DensityMatrix, float]:
    """
    Apply the Extreme Photon Loss (EPL) distillation protocol.

    Protocol steps:
        Initial state: ρ ⊗ ρ (4 qubits total)
        Qubits labeled: q0, q1 (source) and q2, q3 (auxiliary)

        1. Apply CNOT(q2 → q0) and CNOT(q3 → q1)
        2. Measure q2, q3 in computational basis
        3. Post-select on outcome |11⟩
        4. Trace out q2, q3 to get distilled state on q0, q1
        5. Renormalize by success probability

    Args:
        rho: Input two-qubit density matrix (4×4) or DensityMatrix object

    Returns:
        Tuple containing:
            - rho_out: Distilled two-qubit density matrix (conditioned on success)
            - p_success: Probability of successful distillation (float)
    """
    # Build bilateral CNOT circuit
    qc = QuantumCircuit(4)
    qc.cx(2, 0)  # CNOT: control=q2, target=q0
    qc.cx(3, 1)  # CNOT: control=q3, target=q1
    bilateral_CNOT_unitary = Operator(qc)

    # Ensure input is a DensityMatrix object
    if not isinstance(rho, DensityMatrix):
        rho = DensityMatrix(rho)

    # Step 1: Create two-copy state ρ ⊗ ρ
    rho_2_Qbitpair = rho.tensor(rho)

    # Step 2: Apply bilateral CNOTs
    rho_after = rho_2_Qbitpair.evolve(bilateral_CNOT_unitary)

    # Step 3: Compute measurement probabilities for q2, q3
    probs = rho_after.probabilities_dict(qargs=[0, 1])
    p_success = probs.get("11", 0.0)

    # Handle edge case: zero success probability
    if p_success < 1e-15:
        # Return maximally mixed state with zero probability
        return DensityMatrix(np.eye(4) / 4, dims=[2, 2]), 0.0

    # Step 4: Project onto |11⟩ measurement outcome
    # Projector: I ⊗ I ⊗ |1⟩⟨1| ⊗ |1⟩⟨1|
    P1 = np.array([[0, 0], [0, 1]], dtype=complex)
    Pi_23 = np.kron(P1, P1)  # Projector on qubits 2,3
    I_source = np.eye(4, dtype=complex)  # Identity on qubits 0,1
    Pi_full = np.kron(I_source, Pi_23)

    # Apply projection (without normalization)
    post = Pi_full @ rho_after.data @ Pi_full.conj().T

    # Step 5: Wrap as 4-qubit density matrix
    rho_post = DensityMatrix(post, dims=[2, 2, 2, 2])

    # Step 6: Trace out auxiliary qubits (q2, q3)
    rho_out = partial_trace(rho_post, [0, 1])

    # Step 7: Renormalize by success probability
    rho_out = DensityMatrix(rho_out.data / p_success, dims=[2, 2])

    return rho_out, float(p_success)