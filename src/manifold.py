# -*- coding: utf-8 -*-
"""manifold.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v-Y5hoiaDaXiU5kkdFl5X9AeDrm9QScn
"""

import numpy as np
from scipy.linalg import expm
from qiskit.quantum_info import random_unitary

from .metrics import inner_product, trace_norm


def random_stiefel_matrix(n, p):
    """
    take first p columns from a Haar-random unitary (qiskit random_unitary).
    """
    U = random_unitary(n).data
    S = U[:, :p]
    return S


def small_random_rotation_8d(epsilon, d):
    """
    random skew-Hermitian S scaled by epsilon, then Q = expm(S).
    """
    A = np.random.randn(d, d) + 1j * np.random.randn(d, d)
    S = A - np.conj(A).T
    S = epsilon * S
    Q = expm(S)
    return Q


# Build basis matrices (global), exactly like notebook
basis_matrices = []
for i in range(8):
    for j in range(2):
        basis_matrix = np.zeros((8, 2), dtype=complex)
        basis_matrix[i, j] = 1
        basis_matrices.append(basis_matrix)


# ──────────── Projecting the gradient vector ────────────
def Projection_tangent(z, s):
    """
      p = z - s @ (s^† z + z^† s)/2
    """
    p = z - s @ (s.conj().T @ z + z.conj().T @ s) / 2
    return p


def Projection_sub_tangent(z, SA, SB, subsystem_to_change):
    """
    alternating updates over subsystem A/B.
    """
    P = np.zeros_like(z, dtype=complex)

    # ──────────── subsystem to change is A ────────────
    if subsystem_to_change == "A":
        for i in basis_matrices:
            A = np.kron(i, SB) / trace_norm(SB)
            P += inner_product(z, A) * A
            P += inner_product(z, 1j * A) * 1j * A

        B = np.kron(np.eye(8), SB.conj().T) @ P
        P2 = np.zeros_like(SA, dtype=complex)
        for i in range(8):
            for j in range(2):
                P2[i, j] = B[i * 2, j * 2]

        return Projection_tangent(P2, SA)

    # ──────────── subsystem to change is B ────────────
    else:
        for i in basis_matrices:
            A = np.kron(SA, i) / trace_norm(SA)
            P += inner_product(z, A) * A
            P += inner_product(z, 1j * A) * 1j * A

        B = np.kron(SA.conj().T, np.eye(8)) @ P
        P2 = np.zeros_like(SB, dtype=complex)
        P2 = B[:8, :2]

        return Projection_tangent(P2, SB)


def retraction_map(S, delta_S):
    """
    QR-based retraction with sign correction on R diagonal.
    """
    Q, R = np.linalg.qr(S + delta_S)
    d = np.sign(np.diag(R))
    d[d == 0] = 1
    Q = Q * d
    return Q