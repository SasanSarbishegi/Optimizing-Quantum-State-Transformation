# -*- coding: utf-8 -*-
"""bounds.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v-Y5hoiaDaXiU5kkdFl5X9AeDrm9QScn
"""

import numpy as np
import cvxpy as cp
from qiskit.quantum_info import DensityMatrix


# Grid of target success probabilities used in the SDP sweep
deltas = np.linspace(0.01, 0.99, 40)


def pt_B_var(X):
    """
    Partial transpose with respect to subsystem B for a 4x4 Hermitian CVXPY expression.
    We treat X as a 2x2 block matrix with 2x2 blocks and transpose each block.
    """
    X00 = X[0:2, 0:2]
    X01 = X[0:2, 2:4]
    X10 = X[2:4, 0:2]
    X11 = X[2:4, 2:4]

    return cp.bmat(
        [
            [cp.transpose(X00), cp.transpose(X01)],
            [cp.transpose(X10), cp.transpose(X11)],
        ]
    )


def PPT_upper_bound(rho):
    """
    SDP sweep that returns an upper-bound curve indexed by `deltas`.

    Input:
      rho: 4x4 density matrix (numpy array)

    Output:
      objectives: list of optimal values for each delta
    """
    rho = np.real(rho)
    rho_dm = DensityMatrix(rho)

    # Partial transpose on subsystem B
    rho_TB = np.real_if_close(rho_dm.partial_transpose([False, True])).data

    dA = dB = 2
    dAdB = dA * dB
    D = 2

    I4 = np.eye(4)
    objectives = []

    for delta in deltas:
        # Decision variables
        M = cp.Variable((4, 4), hermitian=True)
        E = cp.Variable((4, 4), hermitian=True)

        M_TB = pt_B_var(M)
        E_TB = pt_B_var(E)

        # Constraints (structured exactly as before; only formatted)
        constraints = [
            M >> 0,
            E >> 0,
            M + E << I4 / dAdB,
            M_TB + E_TB << I4 / (dAdB * delta),
            dAdB * cp.real(cp.trace(rho_TB @ (M + E))) == delta,
            M_TB + (1 / (D + 1)) * E_TB >> 0,
            -M_TB + (1 / (D - 1)) * E_TB >> 0,
        ]

        # Objective
        objective = cp.Maximize((dAdB / delta) * cp.real(cp.trace(rho_TB @ M)))
        problem = cp.Problem(objective, constraints)

        # Solver settings: stable for this kind of SDP sweep
        problem.solve(
            solver=cp.SCS,
            verbose=False,
            eps=1e-6,
            max_iters=200000,
        )

        objectives.append(problem.value)

    return objectives