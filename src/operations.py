# -*- coding: utf-8 -*-
"""operations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v-Y5hoiaDaXiU5kkdFl5X9AeDrm9QScn
"""

import numpy as np


def Transformed_rho(S, rho):
    """
    A = S rho S^†
    rho_out = sum of 16 diagonal 4×4 blocks of A
    """
    A = S @ rho @ np.conj(S).T
    rho_out = np.zeros((4, 4), dtype=complex)
    for i in range(16):
        rho_out += A[i * 4 : (i + 1) * 4, i * 4 : (i + 1) * 4]
    return rho_out


# ──────────── build the row-ordering produced by action of U ────────────
def U_action(A):

    rearranged_A = np.zeros_like(A)
    for block_idx in range(4):
        block = A[block_idx * 16 : (block_idx + 1) * 16, :]
        sub_matrices = [block[i * 8 : (i + 1) * 8, :] for i in range(2)]

        for row_idx in range(4):
            new_matrix = np.vstack(
                [sub_matrices[i][row_idx * 2 : row_idx * 2 + 2, :] for i in range(2)]
            )
            rearranged_A[
                block_idx * 16 + row_idx * 4 : block_idx * 16 + (row_idx + 1) * 4, :
            ] = new_matrix
    return rearranged_A


def U_action_transpose(matrix):

    new_matrix = np.zeros_like(matrix)
    for block_idx in range(4):
        block = matrix[block_idx * 16 : (block_idx + 1) * 16, :]
        sub_matrices = [block[i * 2 : (i + 1) * 2, :] for i in range(8)]

        first_8x4 = np.vstack((sub_matrices[0], sub_matrices[2],
                               sub_matrices[4], sub_matrices[6]))

        second_8x4 = np.vstack((sub_matrices[1], sub_matrices[3],
                                sub_matrices[5], sub_matrices[7]))

        combined_block = np.vstack((first_8x4, second_8x4))
        new_matrix[block_idx * 16 : (block_idx + 1) * 16, :] = combined_block
    return new_matrix