# -*- coding: utf-8 -*-
"""manifold_function.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v-Y5hoiaDaXiU5kkdFl5X9AeDrm9QScn
"""

import numpy as np
from typing import Literal
from constants import BASIS_MATRICES


def inner_product(A: np.ndarray, B: np.ndarray) -> float:
    """
    Compute the real-valued inner product between two matrices.

    Inner product: ⟨A, B⟩ = Re(Tr(A† B))

    Args:
        A: First matrix
        B: Second matrix

    Returns:
        float: Real inner product value
    """
    return np.real(np.trace(A.conj().T @ B))


def trace_norm(A: np.ndarray) -> float:
    """
    Compute the Frobenius/trace norm of a matrix.

    Args:
        A: Input matrix

    Returns:
        float: Frobenius norm
    """
    return np.sqrt(inner_product(A, A))


def projection_tangent(z: np.ndarray, s: np.ndarray) -> np.ndarray:
    """
    Project a matrix z onto the tangent space of the Stiefel manifold at point s.

    Args:
        z: Matrix to project (n×p)
        s: Point on Stiefel manifold (n×p with orthonormal columns)

    Returns:
        np.ndarray: Projected matrix in tangent space T_s St(n,p)
    """
    p = z - s @ (s.conj().T @ z + z.conj().T @ s) / 2
    return p


def projection_sub_tangent(
    z: np.ndarray,
    SA: np.ndarray,
    SB: np.ndarray,
    subsystem_to_change: Literal['A', 'B']
) -> np.ndarray:
    """
    Project gradient onto tangent space of a single subsystem's Stiefel manifold.

    Args:
        z: Gradient matrix to project (64×16)
        SA: Stiefel matrix for subsystem A (8×2)
        SB: Stiefel matrix for subsystem B (8×2)
        subsystem_to_change: Which subsystem to project onto ('A' or 'B')

    Returns:
        np.ndarray: Projected gradient (8×2) in tangent space of specified subsystem
    """
    P = np.zeros_like(z, dtype=complex)

    if subsystem_to_change == 'A':
        # Project for subsystem A (keeping B fixed)
        norm_SB = trace_norm(SB)

        # Decompose z in tensor product basis
        for basis_mat in BASIS_MATRICES:
            A = np.kron(basis_mat, SB) / norm_SB
            # Real and imaginary components
            P += inner_product(z, A) * A
            P += inner_product(z, 1j * A) * 1j * A

        # Extract SA component
        B = np.kron(np.eye(8), SB.conj().T) @ P
        P2 = np.zeros_like(SA, dtype=complex)
        for i in range(8):
            for j in range(2):
                P2[i, j] = B[i * 2, j * 2]

        return projection_tangent(P2, SA)

    else:  # subsystem_to_change == 'B'
        # Project for subsystem B (keeping A fixed)
        norm_SA = trace_norm(SA)

        # Decompose z in tensor product basis
        for basis_mat in BASIS_MATRICES:
            A = np.kron(SA, basis_mat) / norm_SA
            # Real and imaginary components
            P += inner_product(z, A) * A
            P += inner_product(z, 1j * A) * 1j * A

        # Extract SB component
        B = np.kron(SA.conj().T, np.eye(8)) @ P
        P2 = B[:8, :2]

        return projection_tangent(P2, SB)


def retraction_map(S: np.ndarray, delta_S: np.ndarray) -> np.ndarray:
    """
    Retract a tangent vector back onto the Stiefel manifold.
    This implements the QR-based retraction, which takes a point S on the manifold
    and a tangent vector delta_S, and returns a new point on the manifold.

    Args:
        S: Current point on Stiefel manifold (n×p)
        delta_S: Tangent vector at S (n×p)

    Returns:
        np.ndarray: New point on Stiefel manifold (n×p with orthonormal columns)
    """
    Q, R = np.linalg.qr(S + delta_S)

    # Ensure unique representation by fixing signs
    d = np.sign(np.diag(R))
    d[d == 0] = 1  # Avoid zero diagonal elements
    Q = Q * d

    return Q


def U_action(A: np.ndarray) -> np.ndarray:
    """
    Apply the U-action row reordering transformation.

    This transformation rearranges the rows of a 64×16 matrix according to a specific
    pattern that arises from the tensor product structure of the quantum system.
    The transformation respects the four-qubit block structure.

    Note: To improve the program's execution speed, we simulate the action of U
    on a 64x16 matrix.

    Args:
        A: Input matrix (64×16)

    Returns:
        np.ndarray: Reordered matrix (64×16)


    """
    rearranged_A = np.zeros_like(A)

    for block_idx in range(4):
        # Extract 16×16 block
        block = A[block_idx * 16:(block_idx + 1) * 16, :]

        # Split into two 8×16 sub-blocks
        sub_matrices = [block[i * 8:(i + 1) * 8, :] for i in range(2)]

        # Interleave rows from sub-blocks
        for row_idx in range(4):
            new_matrix = np.vstack([
                sub_matrices[i][row_idx * 2:row_idx * 2 + 2, :]
                for i in range(2)
            ])
            rearranged_A[block_idx * 16 + row_idx * 4:
                         block_idx * 16 + (row_idx + 1) * 4, :] = new_matrix

    return rearranged_A


def U_action_transpose(matrix: np.ndarray) -> np.ndarray:
    """
    Apply the transpose/inverse of the U-action transformation.

    This is the inverse operation of U_action, reversing the row reordering.
    Used when transforming gradients back to the original coordinate system.

    Args:
        matrix: Input matrix (64×16)

    Returns:
        np.ndarray: Reordered matrix (64×16)
    """
    new_matrix = np.zeros_like(matrix)

    for block_idx in range(4):
        # Extract 16×16 block
        block = matrix[block_idx * 16:(block_idx + 1) * 16, :]

        # Extract pairs of rows
        sub_matrices = [block[i * 2:(i + 1) * 2, :] for i in range(8)]

        # Reassemble into two 8×16 blocks
        first_8x4 = np.vstack((sub_matrices[0], sub_matrices[2],
                               sub_matrices[4], sub_matrices[6]))

        second_8x4 = np.vstack((sub_matrices[1], sub_matrices[3],
                                sub_matrices[5], sub_matrices[7]))

        combined_block = np.vstack((first_8x4, second_8x4))
        new_matrix[block_idx * 16:(block_idx + 1) * 16, :] = combined_block

    return new_matrix