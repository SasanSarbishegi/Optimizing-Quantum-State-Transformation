# -*- coding: utf-8 -*-
"""quantum_utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v-Y5hoiaDaXiU5kkdFl5X9AeDrm9QScn
"""

import numpy as np
from qiskit.quantum_info import DensityMatrix, random_unitary
from typing import Union

from constants import U_BELL, STIEFEL_DIM_N


def FEF(rho: Union[np.ndarray, DensityMatrix]) -> float:
    """
    Calculate the Fully Entangled Fraction (FEF) of a two-qubit density matrix.

    The FEF measures the maximal overlap of a state with a maximally entangled state,
    computed in the Bell basis.

    Args:
        rho: Two-qubit density matrix (4x4 array or DensityMatrix object)

    Returns:
        float: FEF value in [0, 1]
    """
    if isinstance(rho, np.ndarray):
        rho = DensityMatrix(rho)

    # Transform to Bell basis
    rho_bell = rho.evolve(U_BELL)
    eigvals = np.linalg.eigvals(np.real(rho_bell.data))

    return float(max(np.real_if_close(eigvals)))


def random_stiefel_matrix(n: int, p: int) -> np.ndarray:
    """
    Generate a random matrix on the Stiefel manifold St(n, p).

    The Stiefel manifold consists of n×p matrices with orthonormal columns.

    Args:
        n: Number of rows
        p: Number of columns (p <= n)

    Returns:
        np.ndarray: Random n×p matrix with orthonormal columns
    """
    if p > n:
        raise ValueError(f"p ({p}) must be <= n ({n}) for Stiefel manifold")

    U = random_unitary(n).data
    S = U[:, :p]
    return S


def transformed_rho(S: np.ndarray, rho: np.ndarray) -> np.ndarray:
    """
    Apply a transformation S to density matrix rho and trace out auxiliary systems.

    This implements the action: ρ_out = Tr_aux(S ρ S†) where auxiliary systems
    are traced out in blocks.

    Args:
        S: Transformation matrix (64×16)
        rho: Input density matrix (4×4)

    Returns:
        np.ndarray: Transformed two-qubit density matrix (4×4)
    """
    A = S @ rho @ np.conj(S).T
    rho_out = np.zeros((4, 4), dtype=complex)

    # Sum over 4×4 diagonal blocks
    for i in range(16):
        rho_out += A[i*4:(i+1)*4, i*4:(i+1)*4]

    return rho_out


def small_random_rotation_8d(epsilon: float, d: int = STIEFEL_DIM_N) -> np.ndarray:
    """
    Generate a small random rotation in d-dimensional complex space.

    Creates a unitary matrix close to identity by exponentiating a small
    skew-Hermitian matrix.

    Args:
        epsilon: Size parameter for rotation (small values give rotations near identity)
        d: Dimension of the space (default: 8)

    Returns:
        np.ndarray: d×d unitary matrix
    """
    # Generate random complex matrix
    A = np.random.randn(d, d) + 1j * np.random.randn(d, d)

    # Make skew-Hermitian
    S = A - np.conj(A).T
    S = epsilon * S

    # Exponentiate to get unitary
    from scipy.linalg import expm
    Q = expm(S)

    return Q


def S_state(p: float) -> np.ndarray:
    """
    Generate an S-state with parameter p.

    S-state: p|Φ⁺⟩⟨Φ⁺| + (1-p)|00⟩⟨00|

    Args:
        p: Mixing parameter in [0, 1]

    Returns:
        np.ndarray: 4×4 density matrix
    """
    from constants import PHI_PLUS
    return p * PHI_PLUS + (1 - p) * np.diag([1, 0, 0, 0])


def R_state(p: float) -> np.ndarray:
    """
    Generate an R-state with parameter p.

    R-state: p|Φ⁺⟩⟨Φ⁺| + (1-p)|01⟩⟨01|

    Args:
        p: Mixing parameter in [0, 1]

    Returns:
        np.ndarray: 4×4 density matrix
    """
    from constants import PHI_PLUS, H2
    return p * PHI_PLUS + (1 - p) * H2


def RS_state(p: float) -> np.ndarray:
    """
    Generate an RS-state with parameter p.

    RS-state: p|Φ⁺⟩⟨Φ⁺| + (1-p)(|00⟩⟨00| + |01⟩⟨01|)/2

    Args:
        p: Mixing parameter in [0, 1]

    Returns:
        np.ndarray: 4×4 density matrix
    """
    from constants import PHI_PLUS
    return p * PHI_PLUS + (1 - p) * np.diag([1, 1, 0, 0]) / 2