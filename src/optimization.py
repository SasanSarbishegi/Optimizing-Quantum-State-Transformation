# -*- coding: utf-8 -*-
"""optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v-Y5hoiaDaXiU5kkdFl5X9AeDrm9QScn
"""

import numpy as np
from qiskit.quantum_info import DensityMatrix
from .metrics import trace_norm
from .manifold import Projection_sub_tangent
from .operations import U_action, U_action_transpose


def state_transformation(
    rho,
    SA,
    SB,
    H,
    M,
    max_iteration,
    tol=1e-6,
    step_size=0.001,
):
    """
    Alternating (A/B) manifold-gradient updates to reduce moment mismatch.

    Goal:
        For each k:
            Tr(S rho S^† H'_k) ≈ M_k
        where H'_k = I_16 ⊗ H_k and S is the structured operator from SA, SB.

    Returns:
        (loss_list, SA, SB)
    """
    if isinstance(rho, DensityMatrix):
        rho = rho.data

    loss_list = []
    I16 = np.eye(16)
    H_prime = [np.kron(I16, h) for h in H]

    subsystem = "A"
    prev_loss = None

    for _ in range(max_iteration):
        # Structured map S
        S = U_action(np.kron(SA, SB))

        # Moment residuals: (target - achieved)
        residuals = [
            (m_k - np.trace(S @ rho @ S.conj().T @ h_k))
            for m_k, h_k in zip(M, H_prime)
        ]

        loss_norm = np.linalg.norm(residuals)

        # stopping: stable loss value
        if loss_norm < tol:
            break
        if prev_loss is not None and abs(loss_norm - prev_loss) < tol:
            break
        prev_loss = loss_norm

        # Ambient-space gradient for the stacked operator S
        gradient = np.sum(
            [
                U_action_transpose(2 * (h_k @ S) @ rho) * r_k
                for h_k, r_k in zip(H_prime, residuals)
            ],
            axis=0,
        )

        # Project gradient to the tangent space of the chosen subsystem
        delta = Projection_sub_tangent(gradient, SA, SB, subsystem)

        # Normalize step (avoid division-by-zero)
        denom = max(np.sqrt(trace_norm(delta)), 1e-12)
        update = (step_size / denom) * delta

        if subsystem == "A":
            SA = SA + update
            subsystem = "B"
        else:
            SB = SB + update
            subsystem = "A"

        loss_list.append(loss_norm)

    return loss_list, SA, SB


def Probabilistic_local_operation(
    rho,
    SA,
    SB,
    H,
    P,
    max_iteration,
    tol_obj=1e-6,
    step_size=0.001,
):
    """
    Alternating (A/B) updates to maximize a conditional objective.

    Define:
        A = S rho S^† P
        prob = Tr(A)
        obj  = Tr(A H' P) / prob,  where H' = I_16 ⊗ H

    Returns:
        (list_objective, list_probability, SA, SB)
    """
    if isinstance(rho, DensityMatrix):
        rho = rho.data

    I16 = np.eye(16)
    H_prime = np.kron(I16, H)

    subsystem = "A"
    list_objective = []
    list_probability = []
    prev_obj = None

    for _ in range(max_iteration):
        S = U_action(np.kron(SA, SB))

        # success probability
        A = S @ rho @ S.conj().T @ P
        prob = np.trace(A)

        # guard against degenerate probability
        if abs(prob) < 1e-15:
            break

        # conditional objective
        obj = np.trace(A @ H_prime @ P) / prob

        # stopping: stable objective value
        if prev_obj is not None and abs(obj - prev_obj) < tol_obj:
            break
        prev_obj = obj

        # Gradient
        term1 = U_action_transpose(2 * P @ H_prime @ P @ S @ rho) / prob
        term2 = U_action_transpose(2 * P @ S @ rho) * (obj / prob)
        gradient = term1 - term2

        delta = Projection_sub_tangent(gradient, SA, SB, subsystem)

        denom = max(np.sqrt(trace_norm(delta)), 1e-12)
        update = (step_size / denom) * delta

        if subsystem == "A":
            SA = SA + update
            subsystem = "B"
        else:
            SB = SB + update
            subsystem = "A"

        list_objective.append(obj)
        list_probability.append(prob)

    return list_objective, list_probability, SA, SB