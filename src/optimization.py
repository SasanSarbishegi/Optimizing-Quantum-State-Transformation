# -*- coding: utf-8 -*-
"""optimization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v-Y5hoiaDaXiU5kkdFl5X9AeDrm9QScn
"""

"""
Optimization algorithms for quantum state transformations under locality constraints.

This module implements two main optimization problems:
1. State transformation: Transform an input state to match target expectation values
2. Probabilistic local operations: Maximize fidelity under probabilistic local measurement
"""

import numpy as np
from typing import List, Tuple

from .manifold_ops import (
    projection_sub_tangent,
    trace_norm,
    U_action,
    U_action_transpose
)


def state_transformation(
    rho: np.ndarray,
    SA: np.ndarray,
    SB: np.ndarray,
    H: List[np.ndarray],
    M: List[float],
    max_iteration: int,
    tol: float = 1e-6,
    step_size: float = 0.001
) -> Tuple[List[float], np.ndarray, np.ndarray]:
    """
    Optimize quantum state transformation to match target expectation values.

    Args:
        rho: Initial density matrix (4×4)
        SA: Initial Stiefel matrix for subsystem A (8×2)
        SB: Initial Stiefel matrix for subsystem B (8×2)
        H: List of Hermitian observables (each 4×4)
        M: List of target expectation values (same length as H)
        max_iteration: Maximum number of optimization iterations
        tol: Convergence tolerance for loss change (default: 1e-6)
        step_size: Step size for gradient updates (default: 0.001)

    Returns:
        tuple: Contains:
            - Loss_list (List[float]): Loss value at each iteration
            - SA_Final (np.ndarray): Optimized Stiefel matrix for subsystem A (8×2)
            - SB_Final (np.ndarray): Optimized Stiefel matrix for subsystem B (8×2)
    """
    Loss_list = []
    I = np.eye(16)

    H_prime = [np.kron(I, h) for h in H]

    subsystem = 'A'
    prev_loss = None

    for iteration in range(max_iteration):
        S = U_action(np.kron(SA, SB))

        Loss_observable = [
            (p - np.trace(S @ rho @ S.conj().T @ h_prime))
            for p, h_prime in zip(M, H_prime)
        ]

        loss_norm = np.linalg.norm(Loss_observable)

        if prev_loss is not None and abs(loss_norm - prev_loss) < tol:
            break
        prev_loss = loss_norm

        Gradient = np.sum([
            U_action_transpose(2 * (h_p @ S) @ rho) * l
            for h_p, l in zip(H_prime, Loss_observable)
        ], axis=0)

        # Project gradient onto tangent space
        delta_S = projection_sub_tangent(Gradient, SA, SB, subsystem) / loss_norm

        step = delta_S * step_size / np.sqrt(trace_norm(delta_S))

        if subsystem == 'A':
            SA = SA + step
        else:
            SB = SB + step

        # Alternate between subsystems
        subsystem = 'B' if subsystem == 'A' else 'A'

        Loss_list.append(loss_norm)

    return Loss_list, SA, SB


def probabilistic_local_operation(
    rho: np.ndarray,
    SA: np.ndarray,
    SB: np.ndarray,
    H: np.ndarray,
    P: np.ndarray,
    max_iteration: int,
    tol_obj: float = 1e-6,
    step_size: float = 0.001
) -> Tuple[List[float], List[float], np.ndarray, np.ndarray]:
    """
    Maximize fidelity of quantum state under probabilistic local measurement.

    Args:
        rho: Initial density matrix (4×4)
        SA: Initial Stiefel matrix for subsystem A (8×2)
        SB: Initial Stiefel matrix for subsystem B (8×2)
        H: Target Hermitian observable (4×4), typically Φ⁺ for maximizing entanglement
        P: Post-selection measurement projector (64×64)
        max_iteration: Maximum number of optimization iterations
        tol_obj: Convergence tolerance for objective change (default: 1e-6)
        step_size: Step size for gradient updates (default: 0.001)

    Returns:
        tuple: Contains:
            - list_objective (List[float]): Conditional fidelity at each iteration
            - list_probability (List[float]): Success probability at each iteration
            - SA_Final (np.ndarray): Optimized Stiefel matrix for subsystem A (8×2)
            - SB_Final (np.ndarray): Optimized Stiefel matrix for subsystem B (8×2)
    """
    I = np.eye(16)
    H_prime = np.kron(I, H)

    subsystem = 'A'
    list_objective = []
    list_probability = []
    prev_obj = None

    for iteration in range(max_iteration):
        S = U_action(np.kron(SA, SB))

        A = S @ rho @ S.conj().T @ P
        prob = np.trace(A)

        obj = np.trace(A @ H_prime @ P) / prob

        if prev_obj is not None and abs(obj - prev_obj) < tol_obj:
            break
        prev_obj = obj

        term1 = U_action_transpose(2 * P @ H_prime @ P @ S @ rho) / prob
        term2 = U_action_transpose(2 * P @ S @ rho) * (obj / prob)
        Gradient = term1 - term2

        # Project onto tangent space
        delta_S = projection_sub_tangent(Gradient, SA, SB, subsystem)
        update = delta_S * step_size / np.sqrt(trace_norm(delta_S))

        if subsystem == 'A':
            SA = SA + update
        else:
            SB = SB + update

        # Alternate between subsystems
        subsystem = 'B' if subsystem == 'A' else 'A'

        list_objective.append(obj)
        list_probability.append(prob)

    return list_objective, list_probability, SA, SB